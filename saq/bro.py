# vim: sw=4:ts=4:et:cc=120

from datetime import datetime, UTC
import os.path
import re
import logging
import collections

from saq.environment import get_local_timezone

# regular expressions for parsing smtp files generated by bro extraction (see bro/ directory)
REGEX_BRO_SMTP_SOURCE_IPV4 = re.compile(r'^([^:]+):(\d+).*$')
REGEX_BRO_SMTP_MAIL_FROM = re.compile(r'^> MAIL FROM:<([^>]+)>.*$')
REGEX_BRO_SMTP_RCPT_TO = re.compile(r'^> RCPT TO:<([^>]+)>.*$')
REGEX_BRO_SMTP_DATA = re.compile(r'^< DATA 354.*$')
REGEX_BRO_SMTP_RSET = re.compile(r'^[<>] RSET.*$')

RFC822Email = collections.namedtuple('RFC822Email', [
    'source_ipv4', 
    'source_port',
    'envelope_from',
    'envelope_to',
    'received',
    'file_path'])

def parse_bro_smtp(smtp_path, target_dir, prefix='smtp'):
    """Parses a SMTP file generated by bro/ace_smtp.zeek returning a list of generated RFC 822 formatted files.

    Args:
        smtp_path: Path to the SMTP file to parse.
        target_dir: Directory to place the RFC822 formatted email files into.
        prefix: Optional prefix for the names of the email files. The name of each file has the following format:
            prefix.index.email.rfc822
            where prefix is this parameter (defaults to 'smtp')
            index is the zero-based index of the email inside of the stream data

    Returns:
        Yields RFC822Email objects for each parsed email.
    """

    # the current message we're parsing in the case of multiple emails coming in over the same connection
    smtp_message_index = 0 

    with open(smtp_path, 'r', errors='ignore') as fp:
        source_ipv4 = None
        source_port = None
        envelope_from = None
        envelope_to = []

        # state flag for when the data isn't quite right (see below)
        _bypass_read = False

        # the first line of the file has the source IP address of the smtp connection
        # in the following format: 172.16.139.143:38668/tcp

        line = fp.readline()
        m = REGEX_BRO_SMTP_SOURCE_IPV4.match(line)

        if not m:
            logging.info(f"unable to parse soure address from {smtp_path} ({line.strip()})")
            event_time = get_local_timezone().localize(datetime.fromtimestamp(os.path.getmtime(smtp_path)))
            # in this case we skip the first readline() call since we've already read it
            _bypass_read = True
        else:
            source_ipv4 = m.group(1)
            source_port = m.group(2)

            logging.debug(f"got source ipv4 {source_ipv4} port {source_port} for {smtp_path}")

            # the second line is the time (in epoch UTC) that bro received the file
            line = fp.readline()
            event_time = datetime.fromtimestamp(int(line.strip()), UTC)
            logging.debug(f"got event time {event_time} for {smtp_path}")

        STATE_SMTP = 1
        STATE_DATA = 2

        state = STATE_SMTP
        rfc822_path = None
        rfc822_fp = None

        def _reset_state():
            nonlocal rfc822_fp, source_ipv4, source_port, envelope_from, envelope_to, state
            rfc822_fp = None
            #source_ipv4 = None
            #source_port = None
            envelope_from = None
            envelope_to = []
            state = STATE_SMTP

        def _finalize():
            # called when we detect the end of an SMTP stream OR the end of the file (data)
            nonlocal rfc822_fp, source_ipv4, source_port, envelope_from, envelope_to, state
            rfc822_fp.close()
            logging.info("finished parsing {} from {}".format(rfc822_path, smtp_path))
            result = RFC822Email(
                    source_ipv4=source_ipv4,
                    source_port=source_port,
                    envelope_from=envelope_from,
                    envelope_to=envelope_to,
                    received=event_time,
                    file_path=rfc822_path)
            _reset_state()
            return result

        # smtp is pretty much line oriented
        while True:

            # if we read the first line and it wasn't what we expected
            # then we skip reading it here since we already have it
            if _bypass_read:
                _bypass_read = False
            else:
                line = fp.readline()

            if line == '':
                break

            if state == STATE_SMTP:
                m = REGEX_BRO_SMTP_MAIL_FROM.match(line)
                if m:
                    envelope_from = m.group(1)
                    logging.debug("got envelope_from {} for {}".format(envelope_from, smtp_path))
                    continue

                m = REGEX_BRO_SMTP_RCPT_TO.match(line)
                if m:
                    envelope_to.append(m.group(1))
                    logging.debug("got envelope_to {} for {}".format(envelope_to, smtp_path))
                    continue

                m = REGEX_BRO_SMTP_DATA.match(line)
                if m or (not line.startswith('<') and not line.startswith('>')):
                    state = STATE_DATA
                    rfc822_path = os.path.join(target_dir, f'{prefix}.{smtp_message_index}.email.rfc822')
                    smtp_message_index += 1
                    rfc822_fp = open(rfc822_path, 'w')
                    logging.debug("created {} for {}".format(rfc822_path, smtp_path))
                    if not line.startswith('<') and not line.startswith('>'):
                        rfc822_fp.write(line)

                    continue

                m = REGEX_BRO_SMTP_RSET.match(line)
                if m:
                    logging.debug(f"detected RSET for {smtp_path}")
                    _reset_state()
                    continue

                # any other command we skip
                logging.debug(f"skipping SMTP command {line.strip()}")
                continue

            # otherwise we're reading DATA and looking for the end of that
            if line.strip() == ('> . .'):
                yield _finalize()
                continue

            rfc822_fp.write(line)
            continue

        # did the file end while we were reading SMTP data?
        if state == STATE_DATA:
            yield _finalize()
