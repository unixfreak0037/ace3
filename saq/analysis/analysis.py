import logging
from typing import TYPE_CHECKING, Any, Callable, Optional
import uuid

from saq.analysis.detectable import DetectionManager
from saq.analysis.file_manager.file_manager_interface import FileManagerInterface
from saq.analysis.module_path import MODULE_PATH
from saq.analysis.pivot_link import PivotLink
from saq.analysis.search import search_down
from saq.analysis.serialize.analysis_serializer import AnalysisSerializer
from saq.analysis.sortable import SortManager
from saq.analysis.taggable import TagManager
from saq.analysis.event_source import EventSource
from saq.constants import EVENT_ANALYSIS_MARKED_COMPLETED, EVENT_OBSERVABLE_ADDED

if TYPE_CHECKING:
    from saq.analysis.observable import Observable
    from saq.analysis.analysis_tree.analysis_tree_manager import AnalysisTreeManager

class SummaryDetail():
    """Represents a summary detail to present to the analyst.

    Details added to Analysis objects are displayed inline with the analysis
    tree. Details added to RootAnalysis are displayed at the top of the
    display."""

    ID = 'id'
    HEADER = 'header'
    CONTENT = 'content'
    FORMAT = 'format'

    def __init__(self, header=None, content=None, format=None, id=None):
        # generic uuid
        self.id = str(uuid.uuid4()) if id is None else id
        # the visual header displayed above the summary
        self.header = header
        # the actual content of the summary
        self.content = content
        # the format of the content (see saq/constants.py for SUMMARY_DETAIL_FORMAT_* values)
        self.format = format

    def to_dict(self):
        return {
            SummaryDetail.ID: self.id,
            SummaryDetail.HEADER: self.header,
            SummaryDetail.CONTENT: self.content,
            SummaryDetail.FORMAT: self.format,
        }

    @staticmethod
    def from_dict(d):
        result = SummaryDetail()
        if SummaryDetail.ID in d:
            result.id = d[SummaryDetail.ID]
        if SummaryDetail.HEADER in d:
            result.header = d[SummaryDetail.HEADER]
        if SummaryDetail.CONTENT in d:
            result.content = d[SummaryDetail.CONTENT]
        if SummaryDetail.FORMAT in d:
            result.format = d[SummaryDetail.FORMAT]
        return result

    @property
    def json(self):
        return self.to_dict()

    def __eq__(self, other):
        if not isinstance(other, SummaryDetail):
            return False

        return self.id == other.id

class Analysis(EventSource):
    """Represents an output of analysis work."""

    def __init__(self, sort_order: int=100, *args, **kwargs):
        super().__init__(*args, **kwargs)

        # a reference to the RootAnalysis object this analysis belongs to (injected)
        self._analysis_tree_manager: Optional["AnalysisTreeManager"] = None

        # file I/O manager (injected)
        self._file_manager: Optional[FileManagerInterface] = None

        # list of Observables generated by this Analysis
        self._observables: list["Observable"] = []

        # a temporary list of Observable UUIDs that will be used to load self._observables
        self.observable_references: list[str] = []

        # represents the instance of the AnalysisModule that generated this Analysis
        # this defaults to None if the module has no defined instances
        self.instance: Optional[str] = None

        # the observable this Analysis is for
        # this is optional because the root node does not have a parent
        self._observable: Optional["Observable"] = None

        # a brief (or brief-ish summary of what the Analysis produced)
        # the idea here is that the analyst can read this summary and get
        # a pretty good idea of what was discovered without needing to
        # load all the details of the alert
        self._summary: Optional[str] = None

        # the list of SummaryDetail objects that have been added
        # these are used to display useful information to the analyst
        self._summary_details: list[SummaryDetail] = []

        # this flag indicates that the analysis has been fully completed
        # this defaults to True (this is important that it defaults to True)
        # in most cases analysis happens once and that's it
        # but in the case of delayed analysis this would be set to False
        # if this is set to True when the engine will not consider it done
        # (see lib/saq/modules/__init__.py accepts())
        self._completed: bool = True

        # this is set to True when we submit this as an alert
        # currently this is really only supported by the Alert class itself
        # but eventually I would like to be able to alert from any Analysis object
        self._alerted: bool = False

        # set to True when delayed analysis is requested
        self._delayed: bool = False

        # composition-based component managers
        self._tag_manager = TagManager(event_source=self)
        self._detection_manager = DetectionManager(event_source=self)
        self._sort_manager = SortManager(sort_order)

        # a list of external links an analyst can pivot to from this analysis
        self._pivot_links: list[PivotLink] = []

        # the details of the analysis
        # this is a dict that can be used to store any data that is relevant to the analysis
        # NOTE this are not loaded by default when an Analysis is loaded from persistence
        # this must be explicitly loaded by calling load_details()
        self.details: dict = {}

        # where the analysis details are saved
        # if set to None then the analysis details have not been saved yet
        # NOTE this path is relative to the .ace subdirectory of the storage directory
        self.external_details_path: Optional[str] = None

        # the size of the analysis details when saved to disk
        self.details_size: Optional[int] = None

        # this flag indicates that the analysis details have been modified
        # and need to be saved
        self.details_modified = False

    # injection methods
    # ------------------------------------------------------------------------

    def inject_analysis_tree_manager(self, analysis_tree_manager: "AnalysisTreeManager"):
        from saq.analysis.analysis_tree.analysis_tree_manager import AnalysisTreeManager
        assert isinstance(analysis_tree_manager, AnalysisTreeManager)
        self.analysis_tree_manager = analysis_tree_manager

    def inject_file_manager(self, file_manager: FileManagerInterface):
        assert isinstance(file_manager, FileManagerInterface)
        self.file_manager = file_manager

    # managers
    # ------------------------------------------------------------------------

    @property
    def file_manager(self) -> FileManagerInterface:
        if self._file_manager is None:
            raise RuntimeError("file_manager is not set")

        return self._file_manager

    @file_manager.setter
    def file_manager(self, value: FileManagerInterface):
        self._file_manager = value

    @property
    def analysis_tree_manager(self) -> "AnalysisTreeManager":
        if self._analysis_tree_manager is None:
            raise RuntimeError("analysis_tree_manager is not set")

        return self._analysis_tree_manager

    @analysis_tree_manager.setter
    def analysis_tree_manager(self, value: "AnalysisTreeManager"):
        self._analysis_tree_manager = value

    # analysis properties and methods
    # ------------------------------------------------------------------------

    @property
    def whitelisted(self) -> bool:
        return self.has_tag("whitelisted")

    def set_details_modified(self):
        """Calling this function indicates that the details have become modified and thus need to be saved."""
        # this is called automatically when you add an Analysis object to an Observable
        logging.debug("setting details modified for %s", self)
        self.details_modified = True

    def load_details(self) -> bool:
        """Loads the details of this analysis from disk."""
        return self.analysis_tree_manager.load_analysis_details(self)

    @property
    def question(self) -> Optional[str]:
        """Returns the question this analysis was trying to answer.
           By default this returns the __doc__ by default, or subclasses can override it.
           This result is returned to the analyst when they mouse-over in the GUI."""
        return self.__doc__

    @property
    def pivot_links(self) -> list[PivotLink]:
        return self._pivot_links

    @pivot_links.setter
    def pivot_links(self, value: list[PivotLink]):
        assert all([isinstance(_, PivotLink) for _ in value])
        self._pivot_links = value

    def add_pivot_link(self, url: str, icon: Optional[str]=None, text: Optional[str]=None):
        self._pivot_links.append(PivotLink(url, icon, text))

    @property
    def delayed(self) -> bool:
        return self._delayed

    @delayed.setter
    def delayed(self, value: bool):
        assert isinstance(value, bool)
        self._delayed = value

    @property
    def summary(self) -> Optional[str]:
        return self._summary

    @summary.setter
    def summary(self, value: Optional[str]):
        self._summary = value

    @property
    def summary_details(self) -> list[SummaryDetail]:
        """Returns a list of SummaryDetail objects that represent the summaries of analysis performed."""
        return self._summary_details

    @summary_details.setter
    def summary_details(self, value: list[SummaryDetail]):
        self._summary_details = value

    def add_summary_detail(self, *args, **kwargs):
        self.summary_details.append(SummaryDetail(*args, **kwargs))

    @property
    def completed(self) -> bool:
        return self._completed

    @completed.setter
    def completed(self, value: bool):
        assert isinstance(value, bool)

        # if this state is changing from False to True then we want to fire an event
        # so that the engine can pick this up and continue analysis
        # this is because most analysis triggers off of adding Analysis objects to Observables
        # but in the case of delayed analysis the Analysis has already been added and we're just waiting for results
        # once that delayed analysis is completed we want to allow other modules a chance to look at it
        _trigger_event = False
        if not self._completed and value:
            _trigger_event = True

        self._completed = value

        if _trigger_event:
            logging.debug("{} has marked as completed manually (fire event)".format(self))
            self.fire_event(self, EVENT_ANALYSIS_MARKED_COMPLETED)

    @property
    def module_path(self) -> str:
        """Returns module.path:class_name[:instance]."""
        return MODULE_PATH(self)

    def is_on_detection_path(self) -> bool:
        """Returns True if this node or any node down to (but not including) the root has a detection point."""
        from saq.analysis.root import RootAnalysis
        if self.has_detection_points():
            return True

        return search_down(self, lambda obj: False if isinstance(obj, RootAnalysis) else obj.has_detection_points()) is not None

    # tag management
    # ------------------------------------------------------------------------

    @property
    def tags(self):
        return self._tag_manager.tags

    @tags.setter
    def tags(self, value):
        self._tag_manager.tags = value

    def add_tag(self, tag):
        self._tag_manager.add_tag(tag)

    def remove_tag(self, tag):
        self._tag_manager.remove_tag(tag)

    def clear_tags(self):
        self._tag_manager.clear_tags()

    def has_tag(self, tag_value):
        """Returns True if this object has this tag."""
        return self._tag_manager.has_tag(tag_value)

    # detection management
    # ------------------------------------------------------------------------

    @property
    def detections(self):
        return self._detection_manager.detections

    @detections.setter
    def detections(self, value):
        self._detection_manager.detections = value

    def has_detection_points(self):
        """Returns True if this object has at least one detection point, False otherwise."""
        return self._detection_manager.has_detection_points()

    def add_detection_point(self, description, details=None):
        """Adds the given detection point to this object."""
        self._detection_manager.add_detection_point(description, details)

    def clear_detection_points(self):
        self._detection_manager.clear_detection_points()

    # sort management
    # ------------------------------------------------------------------------

    @property
    def sort_order(self):
        return self._sort_manager.sort_order

    @sort_order.setter
    def sort_order(self, value):
        self._sort_manager.sort_order = value

    # JSON serialization delegation methods
    # ------------------------------------------------------------------------

    @property
    def json(self):
        return AnalysisSerializer.serialize(self)

    @json.setter
    def json(self, value):
        AnalysisSerializer.deserialize(self, value)


    # observables
    # ------------------------------------------------------------------------

    @property
    def observable(self) -> Optional["Observable"]:
        """The Observable this Analysis is for (or None if this is an Alert.)"""
        return self._observable

    @observable.setter
    def observable(self, value: Optional["Observable"]):
        from saq.analysis.observable import Observable
        assert value is None or isinstance(value, Observable)
        self._observable = value

    @property
    def observables(self) -> list["Observable"]:
        """A list of Observables that was generated by this Analysis.  These are references to the Observables to Alert.observables."""
        # at run time this is a list of Observable objects which are references to what it stored in the Alert.observable_store
        # when serialized to JSON this becomes a list of uuids (keys to the Alert.observable_store dict)
        return self._observables

    @observables.setter
    def observables(self, value: list["Observable"]):
        from saq.analysis.observable import Observable
        assert isinstance(value, list)
        assert all(isinstance(o, Observable) for o in self._observables)
        self._observables = value

    def has_observable(self, observable: "Observable") -> bool:
        """Returns True if this Analysis has this Observable."""
        return self.find_observable(lambda o: o == observable) is not None

    def has_observable_by_spec(self, o_type: str, o_value: str) -> bool:
        """Returns True if this Analysis has an Observable with the given type and value."""
        return self.find_observable(lambda o: o.type == o_type and o.value == o_value) is not None

    @property
    def children(self) -> list["Observable"]:
        """Returns what is considered all of the "children" of this object (in this case is the the Observables.)"""
        return self.observables

    def _load_observable_references(self):
        """Utility function to replace uuid strings in Analysis.observables with references to Observable objects in Alert.observable_store."""
        _buffer: list["Observable"] = []
        for observable_id in self.observable_references:
            observable = self.analysis_tree_manager.get_observable_by_id(observable_id)
            if observable is None:
                logging.warning("missing observable with uuid {} in {}".format(observable_id, self.analysis_tree_manager.root_analysis))
            else:
                _buffer.append(observable)

        self._observables = _buffer

    @property
    def observable_types(self):
        """Returns the list of unique observable types for all Observables generated by this Analysis."""
        return list(set([o.type for o in self.observables]))

    def get_existing_observable(self, observable: "Observable") -> Optional["Observable"]:
        """Returns the Observable object that matches the given Observable object, or None if no match is found."""
        for target_observable in self.observables:
            if target_observable == observable:
                return target_observable

        return None

    def get_observables_by_type(self, o_type: str) -> list["Observable"]:
        """Returns the list of Observables that match the given type."""
        return [o for o in self.observables if o.type == o_type]

    def get_observable_by_type(self, o_type: str) -> Optional["Observable"]:
        """Returns the first Observable of type o_type, or None if no Observable of that type exists."""
        result = self.get_observables_by_type(o_type)
        if len(result) == 0:
            return None

        return result[0]

    def find_observable(self, criteria: Callable[["Observable"], bool]) -> Optional["Observable"]:
        """Returns the first observable that matches the criteria, or None if nothing is found.

           param:criteria Must be one of the following:
           * a callable that takes a single :class:`Observable` as a parameter and returns a boolean
           * an indicator type (str)

           return: the first observable that matches the criteria, or None if nothing is found."""

        result = self.find_observables(criteria)
        if result:
            return result[0]
        else:
            return None

    def find_observables(self, criteria: Callable[["Observable"], bool]) -> list["Observable"]:
        """Same as :meth:`find_observable` but returns all observables found that match the criteria."""
        result: list["Observable"] = []
        for observable in self.observables:
            if criteria(observable):
                result.append(observable)

        return result

    # observable management (public interface)
    # ------------------------------------------------------------------------

    def add_observable(self, observable: "Observable") -> "Observable":
        """Adds the Observable to this Analysis.  Returns the Observable object, or the one that already existed."""
        from saq.analysis.observable import Observable
        assert isinstance(observable, Observable)
        return self.analysis_tree_manager.add_observable(self, observable)

    def add_observable_by_spec(self, o_type: str, o_value, o_time=None, sort_order=100, volatile=False) -> Optional["Observable"]:
        """Adds this observable specified by type, value and time to this Analysis.  
           Returns the new Observable object, or the one that already existed."""
        return self.analysis_tree_manager.add_observable_by_spec(self, o_type, o_value, o_time=o_time, sort_order=sort_order, volatile=volatile)

    def add_file_observable(self, path: Any, target_path: Optional[str]=None, move: Optional[bool]=False, **kwargs):
        from saq.observables.file import FileObservable
        assert target_path is None or isinstance(target_path, str)
        assert isinstance(move, bool)

        try:
            # Use file manager to store the file
            sha256_hash, relative_path = self.file_manager.store_file(path, target_path, move)
            
            # Create and add the file observable
            return self.analysis_tree_manager.add_observable(
                self,
                FileObservable(
                    sha256_hash, 
                    file_path=relative_path,
                    **kwargs))
                    
        except FileNotFoundError:
            logging.warning("add_file_observable called to non-existant file: %s", path)
            return None
        except Exception as e:
            logging.error("unable to add file observable %s: %s", path, e)
            raise e

    # observable management (private interface)
    # ------------------------------------------------------------------------

    # this should only be called by the AnalysisTreeManager
    def add_observable_to_tree(self, observable: "Observable"):
        """Modifies the analysis tree to include the given observable."""
        from saq.analysis.observable import Observable
        assert isinstance(observable, Observable)
        self._observables.append(observable)
        self.fire_event(self, EVENT_OBSERVABLE_ADDED, observable)

    # special methods
    # ------------------------------------------------------------------------

    def __str__(self):
        result = '{}'.format(type(self).__name__)
        if self.instance is not None:
            result += f':{self.instance}'

        return result

    # this is used to sort in the GUI
    def __lt__(self, other):
        if not isinstance(other, Analysis):
            return False

        self_str = self.summary if self.summary is not None and isinstance(self.summary, str) else str(self)
        other_str = other.summary if other.summary is not None and isinstance(other.summary, str) else str(other)

        return self_str < other_str

    def __eq__(self, other):
        if type(self) is not type(other):
            return False

        return self.details == other.details if self.details and other.details else False

    def __hash__(self):
        # XXX this is weird -- why are we hashing the summary?
        return hash(self.summary)

    ##########################################################################
    # OVERRIDABLES 

    def generate_summary(self) -> Optional[str]:
        """Returns a human readable summary of the analysis.  Returns None if the analysis is not to be displayed in the GUI."""
        return None

    def always_visible(self):
        """If this returns True then this Analysis is always visible in the GUI."""
        return False

# TODO revisit the need for this class
class ReadOnlyAnalysis(Analysis):
    """Represents an Analysis that cannot be modified."""

    def __init__(self, module_path, *args, **kwargs):
        self._module_path = module_path
        super().__init__(*args, **kwargs)

    @Analysis.module_path.getter
    def module_path(self):
        return self._module_path

    def save(self):
        pass

    def flush(self):
        pass

    def reset(self):
        pass

    def discard_details(self):
        pass

    @property
    def details(self):
        return self.persistence_manager.details

    @details.setter
    def details(self, value):
        pass  # Read-only, do nothing

    def clear_observables(self):
        pass

    def add_observable(self, *args, **kwargs):
        pass

    def _add_observable(self, observable):
        pass

    def _add_observable_by_spec(self, o_type, o_value, o_time=None):
        pass

    def tag_detection(self, source, event, tag):
        pass
